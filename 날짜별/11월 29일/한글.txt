이 절에는 각 알고리즘에 대한 이론적 논의와 Figure \ref{fig: plotbym}와 Figure \ref{fig: plotbyn}, 그리고 이론적 시간복잡도를 바탕으로 각 알고리즘의 특성에 대해 논의한다. 논의에 앞서, Figure \ref{fig: plotbym}의 M이 작은 부분에서 일정하게 나타나는 값은 N에 의한 시간으로 볼 수 있으며, 로그 스케일 그래프이므로 기울기가 M의 차수가 된다. 유사하게 Figure \ref{fig: plotbyn}에서는 N이 작은 부분에서 일정하게 나타나는 값은 M에 의한 시간으로, 기울기는 N의 차수로 볼 수 있다. 이제 각 알고리즘에 대해 이론적으로 논의하겠다. BFS와 sweeping의 경우에는 매우 비슷하므로 둘만 묶어 논의하고, 나머지는 따로 논의한다.

이 알고리즘의 기본적인 아이디어는 seed에서부터 시작하며 한 칸씩 확장해나가며 보르노이 다이어그램을 구하는 것이다. 물론 BFS를 이용해 이를 구현할 수 있지만, 보르노이 다이어그램에서 한 seed에 해당하는 영역이 붙어 있지 않을 수 있기 때문에 정확도가 떨어진다. 이를 어느 정도 해결하기 위해 BFS를 확장한 다익스트라 알고리즘을 활용하였다.
다익스트라는 가중치가 있는 그래프에서 점화 관계를 바탕으로 시작 점으로부터 각 점까지의 최단거리를 구하는 방식이다. 이때 점화관계의 정당성을 보장하기 위해 가장 거리가 가까운 점부터 주변으로 확장해나가며, 가장 가까운 점을 빠르게 찾기 위해 우선순위 큐를 사용한다.
BFS는 고정적이지만 다익스트라 알고리즘의 경우에는 비슷한 형태의 다양한 점화식에 대해 적용할 수 있기 때문에 다익스트라 알고리즘을 사용하면 두 번째 최단 경로와 같은 변형된 최단 경로도 구할 수 있다.
본 논문의 \textit{dijkstra} 알고리즘은 한 seed에 해당하는 영역이 붙어 있지 않을 때 최대한 근사해를 찾을 수 있도록 두 번째로 가까운 seed까지 저장하여 그 seed도 업데이트 대상에 포함시키는 방법을 채택하였다. 두 번째로 가까운 seed를 고려하지 않은 경우에는 m = 1000일 때 랜덤으로 뽑은 70개의 데이터 중 48개에서만 정확한 답을 출력한 반면에, 두 번째로 가까운 seed까지 고려한 경우에는 m = 1000일 떄 랜덤으로 뽑은 40개의 데이터 중 69개에서 정확한 답을 출력하였고, 세 번째로 가까운 seed까지 고려한 경우에는 모든 데이터에서 정확한 답을 출력하였다. 또한, n이 커질수록 틀리는 경우가 많아지는 경향을 보였다.
물론 더 많은 개수의 seed를 고려할수록 더 오랜 시간이 걸린다. T개의 seed를 고려한다면 다익스트라에서 업데이트가 T배 많아지고, 매 업데이트에 T배의 시간이 소요되므로 T^2배의 시간이 걸리게 된다. 이를 고려했을 때 T=2가 시간과 정확성의 측면에서 가장 적절한 상수이다.
T=2일 때 Figure \ref{fig: plotbym}을 보면 N의 항에 따른 전처리 시간복잡도가 naive 알고리즘과 비슷한 수준으로 매우 작은 모습을 확인할 수 있다. 하지만, M의 항에 붙은 상수가 크기 때문에 M이 커짐에 따라 다른 알고리즘들보다 속도가 느려지는 모습을 볼 수 있다. 또한, Figure \ref{fig: plotbyn}을 보면 상수항이 큰 것으로부터 M의 항에 따른 시간이 크다. 그리고 N에 따른 기울기가 매우 작으므로 N에 거의 영향을 받지 않는다. 즉, M이 작고 N이 클 때 특히 유용하다.

보르노이 다이어그램을 계산할 때 시간적으로 낭비되는 부분은 각각의 영역이 넓을 때 인접한 두 격자점이 같은 영역에 속할 확률이 높음에도 불구하고 경계를 정확히 모르기 떄문에 매번 모든 seed와의 거리를 구해야 한다는 점이다. 이는 보르노이 다이어그램의 볼록다각형적 성질을 활용하면 해결할 수 있다. 하나의 직사각형에 대해 네 꼭짓점 모두가 같은 영역에 포함된다면 직사각형 내의 모든 점은 같은 영역에 포함되기 때문에 각각의 영역이 넓을 때 크기가 큰 몇 개의 직사각형들로 나누어 처리함으로써 낭비되는 시간을 줄일 수 있다.
물론 이 방법은 N보다 M^2이 큰 경우에만 유효하다. 만약 그렇지 않고 평균적으로 한 칸당 하나 이상의 seed가 포함되는 경우에는 각각의 영역이 너무 좁기 때문에 위와 같은 접근법으로 시간을 단축할 수 없다. 또한, 시간복잡도는 naive 알고리즘과 같지만 naive 알고리즘보다 함수 호출 등이 더 많고 더 많은 횟수만큼 가장 가까운 seed를 찾아야 하기 때문에 상수가 더 큰 것을 확인할 수 있다. 이러한 이유에서 이 알고리즘은 seed들이 희소하게 배치되는 경우에 더 나은 성능을 보이게 되며, 이를 바탕으로 이 알고리즘을 sparse라 이름붙였다.
Figure \ref{fig: plotbym}을 보면 naive 알고리즘과 매우 비슷한 그래프를 그린다. 하지만, 상수가 더 크기 때문에 naive 알고리즘의 그래프가 왼쪽으로 평행이동된 모양이 나타나고 있다. 또한, Figure \ref{fig: plotbyn}을 보면 상수항이 0에 매우 가깝고 가장 작게 나타나는데 N이 매우 작을 때 함수의 호출 횟수가 N에 크게 영향받기 때문으로 해석된다. 즉, 시간복잡도를 정확히 구하지는 못했지만 N이 M^2보다 클 때인 O(NM^2)보다 N의 차수가 더 높게 나타나고, M의 차수가 더 낮게 나타날 것이다.

sparse 알고리즘과 대조적으로 seed들의 밀도가 높은 경우에는 충분히 멀리 있는 seed을 고려하지 않음으로써 낭비되는 시간을 단축할 수 있다. 즉, 처음에 간략하게 가장 가까운 점이 존재할 수 있는 범위를 구하고, 그 범위 내에 있는 점만 살피는 방식이다.
이러한 접근을 사용하기 위해 점 (i-1, j-1)과 (i, j) 사이를 나타내는 격자에 포함되는 seed들의 개수와 번호를 저장한다. 이후 이분탐색을 활용하여 각 격자점에 대해 격자점을 중심으로 하고 한 변의 길이가 2k인 정사각형 안에 seed가 존재하는 k를 찾는다. 그러면 점이 존재할 수 있는 범위가 반지름 \sqrt2 (k+1)인 영역이므로 각 격자마다 존재하는 seed를 전처리한 결과를 이용하여 이미 해당되는 영역 안에 점만을 확인한다.
일반적으로 k가 최솟값이기 떄문에 약 \sqrt2 k배의 영역에 포함되는 점의 개수는 상수개일 것이다. 하지만 k가 크다면 각 격자에 점이 존재하지 않더라도 반복문으로 순회해야 하므로 k^2에 비례하는 시간이 소요되기 된다. 즉, seed들의 밀도가 낮은 경우에는 모든 seed가 멀리 있기 때문이 이 방법이 효율적이지 않으며, seed들의 밀도가 높은 경우에만 효율적임을 확인할 수 있다. 이러한 이유에서 이 알고리즘을 dense라 이름붙였다.
Figure \ref{fig: plotbym}을 보면 M에 따라 폭발적으로 증가하는 시간 그래프를 관찰할 수 있다. 그리고 N=10000으로 큰 값을 사용하였기 때문에 이론적인 시간복잡도에서 나누는 항이 크게 들어가 M의 영향이 다른 알고리즘들보다 큰 지점에서 나타나기 시작한다는 특징이 있다. 또한, Figure \ref{fig: plotbyn}을 보면 N이 10^4 이하일 때 N이 작아짐에 따라 더 시간이 늘어나는 특이한 모습을 확인할 수 있으며, 이는 이론적으로 예측된 특성 및 결과와 합치한다. 그리고 극솟값을 지나 다시 증가하는 그래프 형태가 관찰되는데, 이 이유는 p가 밀도가 충분히 큰 상황에서 N에 대한 영향을 받기 때문이다. 하지만 dijkstra나 quad가 영향을 받는 정도와 비슷하게 영향을 받는다는 점에서 당연한 결과로 보아야 할 것이다.

dense 알고리즘에서 가장 오랜 시간이 소요되는 부분은 이분탐색으로 찾은 값을 바탕으로 구한 고려해야 할 영역에 있는 점을 모두 찾아오는 부분이다. 하지만 이 과정을 merge sort tree의 아이디어를 응용하여 quad tree를 사용하면 해결할 수 있다. 전체 영역을 네 개의 사분면으로 나누어 각각을 quad tree에 저장하고, 직사각형 영역을 quad tree의 각 노드들이 나타내는 영역의 합으로 나타내는 세그먼트 트리의 아이디어와, 각 quad tree에 노드에 수이 아닌 배열을 저장하는 merge sort tree의 아이디어를 합쳤다.
하지만 머지 소트 트리의 아이디어를 사용하면서 머지 소트 트리의 문제 중 하나인 메모리 사용량의 문제가 발생하였다. 물론 각 seed는 최대 O(log^2 M)개의 quad tree의 노드에 포함될 수 있기 떄문에 전체 배열의 길이의 합은 O(N log^2 M)이지만, O(M^2)개의 배열을 만들어서 처리해야 하므로 메모리 사용량을 1GB 이하로 만드려면 M이 2^12 = 4096 미만이어야 한다.
quad tree를 활용하면 dense 알고리즘의 k^2 항을 log^2 M으로 효과적으로 단축할 수 있다. 전처리 시간이 길다는 문제가 있지만, seed들의 밀도가 낮은 경우에도 큰 시간 차이 없이 효과적으로 보르노이 다이어그램을 구할 수 있다.
Figure \ref{fig: plotbym}을 보면 dense 알고리즘보다 n에 따른 전처리 시간과 m에 따른 시간 증가 정도가 모두 작음을 알 수 있다. 그 이유는 quad 알고리즘에서 quad tree의 노드에 저장된 배열의 길이가 0일 경우 더 이상 분할하지 않지만, dense 알고리즘에서는 모든 경우를 살펴야 하기 때문이다. 또한, Figure \ref{fig: plotbyn}을 보면 처음 n이 10^4보다 작을 때는 dense 알고리즘보다 quad 알고리즘의 시간이 훨씬 빠른 것으로 dense 알고리즘의 문제가 해결되었음을 알 수 있다. 그리고 n이 커짐에 따라 그 차이가 줄어들며 n이 커지면 결국 비슷한 computation time이 된다. quad 알고리즘 역시 dijkstra 알고리즘과 유사하게 N의 증가로 인한 시간 증가가 적으므로 M이 작고 N이 클 때 유용하다.

BFS와 sweeping의 경우 모두 보르노이 다이어그램을 구한 결과를 이용한다. 이 결과에는 각 영역을 나누는 경계선과 그 경계선이 어떤 두 seed의 수직이등분선인지, 그리고 두 경계선의 교점에 해당하는 점이 포함되어 있다. 이 결과는 O(N \log N)에 빠르게 계산할 수 있으므로 보르노이 다이어그램을 구한 결과를 사용하면 빠르게 격자를 채울 수 있을 것이다.
BFS는 격자의 경계선으로부터 시작하는 BFS를 진행한다면 한 seed에 해당하는 영역이 붙어 있지 않더라도 시작 점에 경계 근처가 포함되므로 예외가 생기지 않는다. 즉, seed로부터 시작하는 BFS에서 나타나는 문제점을 해결하며 간단하게 격자 보르노이 다이어그램을 완성할 수 있다. 이 알고리즘의 시간복잡도는 경계 건처의 시작점을 정하는데 최대 O(NM)이므로 O(N \log N + NM + M^2)이 된다.
sweeping은 어떤 직선이 보르노이 다이어그램을 이루는 선을 지날 때만 그 직선 위의 점이 포함된 영역이 바뀐다는 것을 이용한다. 즉, 각 가로줄에 대하여 각 선과의 교점을 구하고 x좌표가 증가하는 방향으로 이동하며 격자 보르노이 다이어그램을 채운다. 이 과정에서 BFS에서 했던 것과 같이 경계선 근처에 있는 점을 저장하면 되기 떄문에 두 방법은 전처리 과정이 동일하다. 이 때문에 두 방법의 시간복잡도가 동일하게 나오는 것이다.
Figure \ref{fig: plotbym}을 보면 보르노이 다이어그램을 계산하는 시간 때문에 다익스트라보다 N에 의한 시간복잡도가 크다는 것을 알 수 있다. 하지만 M이 커짐에 따라 가장 빠른 시간에 계산이 완료되는 것을 볼 수 있다. 또한, Figure \ref{fig: plotbyn}을 보았을 때 M에 의한 시간이 작지만 dijkstra나 quad보다 N에 의한 영향이 큰 것을 볼 수 있다. 즉, N이 작고 M이 큰 상황에서 유용하다. 마지막으로 sweeping보다 BFS가 상수가 더 크다. BFS를 활용할 경우 모든 지점을 한 번 이상 확인하는 경우가 많기 때문에 정확히 한 번씩 확인하는 sweeping보다 느리기 떄문이다.





